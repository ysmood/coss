// Generated by CoffeeScript 1.8.0
(function() {

  /**
  	 * The core compiler of coss. Supports nested css and '&' self sugar.
  	 * @param  {Object | Array} source The source data to compile.
  	 * @param  {String} indent Default is 4 spaces.
  	 * @return {String} The compiled code.
  	 * @example
  	 * ```coffeescript
  	 * level = ->
  	 * 	level.count ?= 1
  	 * 	'.level_' + level.count++
  	 *
  	 * # Compile an array css tree.
  	 * # The array compiler can use variable as css selector.
  	 * coss [
  	 * 	['#basic'
  	 * 		['font-size', '12px']
  	 * 		['opacity', 0.8]
  	 * 	]
  	 * 	[level()
  	 * 		['background', 'red']
  	 * 		['border', '1px solid #fff']
  	 *
  	 * 		['&:hover'
  	 * 			['background', 'blue']
  	 * 		]
  	 *
  	 * 		[level()
  	 * 			['margin', '1px']
  	 *
  	 * 			[level()
  	 * 				['padding', 0]
  	 * 			]
  	 * 		]
  	 * 	]
  	 * ]
  	 *
  	 * # Compile an object css tree.
  	 * coss {
  	 * 	'.level_1':
  	 * 		background: 'red'
  	 * 		border: '1px solid #fff'
  	 *
  	 * 		'.level_2':
  	 * 			margin: '1px'
  	 *
  	 * 			'.level_3':
  	 * 				padding: 0
  	 * 	'#another':
  	 * 		'font-size': '12px'
  	 * 		opacity: 0.8
  	 * }
  	 * ```
   */
  var coss;
  coss = function(source, indent) {
    var compile_arr, compile_obj, k, node, ret, type_error, _i, _len;
    if (indent == null) {
      indent = '    ';
    }
    compile_obj = function(node, parents) {
      var children, leaf, props, sel;
      props = '';
      children = '';
      for (sel in node) {
        leaf = node[sel];
        if (typeof leaf === 'object') {
          if (sel.charAt(0) === '&') {
            children += compile_obj(leaf, parents + sel.slice(1));
          } else {
            children += compile_obj(leaf, parents + ' ' + sel);
          }
        } else {
          props += "" + indent + sel + ": " + leaf + ";\n";
        }
      }
      return "" + parents + " {\n" + props + "}\n" + children;
    };
    compile_arr = function(node, parents) {
      var children, defs, leaf, props, sel, _i, _len, _ref;
      props = '';
      children = '';
      parents += node[0];
      _ref = node.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        leaf = _ref[_i];
        defs = leaf[1];
        if (typeof defs === 'object') {
          sel = leaf[0];
          if (sel.charAt(0) === '&') {
            leaf[0] = sel.slice(1);
            children += compile_arr(leaf, parents);
          } else {
            children += compile_arr(leaf, parents + ' ');
          }
        } else {
          props += "" + indent + leaf[0] + ": " + defs + ";\n";
        }
      }
      return "" + parents + " {\n" + props + "}\n" + children;
    };
    type_error = function() {
      throw new Error('The type of source is incorrect.');
    };
    if (typeof source === 'object') {
      ret = '';
      if (typeof source.length === 'number') {
        for (_i = 0, _len = source.length; _i < _len; _i++) {
          node = source[_i];
          if (typeof node === 'object') {
            ret += compile_arr(node, '');
          } else {
            type_error();
          }
        }
      } else {
        for (k in source) {
          node = source[k];
          if (typeof node === 'object') {
            ret += compile_obj(node, k);
          } else {
            type_error();
          }
        }
      }
      return ret;
    } else {
      return type_error();
    }
  };
  if (typeof module === "object" && module && typeof module.exports === "object") {
    return module.exports = coss;
  } else {
    if (typeof define === "function" && define.amd) {
      return define(function() {
        return coss;
      });
    } else {
      return window.coss = coss;
    }
  }
})();
